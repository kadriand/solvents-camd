package co.unal.camd.ga.haea.old;

import co.unal.camd.control.parameters.ContributionParametersManager;
import co.unal.camd.properties.estimation.FunctionalGroupNode;
import co.unal.camd.properties.estimation.GeneticOperator;
import co.unal.camd.properties.estimation.Molecule;
import co.unal.camd.properties.estimation.old.OldMoleculesEnvironment;
import unalcol.agents.simulate.Environment;
import unalcol.search.selection.Selection;
import unalcol.search.variation.Variation_2_2;
import unalcol.types.collection.bitarray.BitArray;

import java.util.Vector;

public class OldCross extends Variation_2_2<Molecule> {

    ContributionParametersManager parametersManager;

    protected Selection selection;

    public OldCross(ContributionParametersManager parametersManager) {
        this.parametersManager = parametersManager;
    }

    public Vector<Molecule> apply(Molecule one, Molecule two) {
        // System.out.println("Cross");
        Molecule clone_genome = one.clone(); // @TODO: clonar objeto
        Molecule clone_genome2 = two.clone(); // @TODO: clonar objeto
        int code;
        int num = (int) (Math.random() * (clone_genome.getTotalGroups()) - 1);
        int num2 = (int) (Math.random() * (clone_genome2.getTotalGroups()) - 1);

        FunctionalGroupNode aGroup1 = one.getGroupAt(num);
        FunctionalGroupNode aGroup2 = two.getGroupAt(num2);

        GeneticOperator.searchAndReplace(clone_genome.getMoleculeByRootGroup(), num, aGroup2, true, parametersManager);
        GeneticOperator.searchAndReplace(clone_genome2.getMoleculeByRootGroup(), num2, aGroup1, true, parametersManager);

        Vector<Molecule> v = new Vector<>();
        v.add(clone_genome);
        v.add(clone_genome2);
        return v;
    }

    /**
     * Apply the operator over the given individuals
     *
     * @param population Source population
     * @param x          Individual used as first parent
     * @return A collection of individuals generated by the operator
     */
    public Vector<Individual> apply(Population population, int x) {
        Vector<Individual> children = null;
        if (population != null && selection != null) {
            Vector<Individual> parents = selection.choose(population, x);
            // only for two children
            Vector<Molecule> genomes = apply((Molecule) parents.get(0).getGenome(),
                    (Molecule) parents.get(1).getGenome());
            children = new Vector<Individual>();
            children.add(new Individual<Molecule, Molecule>(genomes.get(0)));
            children.add(new Individual<Molecule, Molecule>(genomes.get(1)));
        }
        return children;
    }

    /**
     * Return the genetic operator arity
     *
     * @return the genetic operator arity
     */
    public int getArity() {
        return 2;
    }

}
