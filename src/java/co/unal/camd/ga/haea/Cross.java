package co.unal.camd.ga.haea;

import co.unal.camd.properties.estimation.GeneticOperator;
import co.unal.camd.properties.estimation.Molecules;
import co.unal.camd.properties.estimation.MoleculesEnviroment;
import co.unal.camd.properties.estimation.Node;
import unalcol.evolution.Environment;
import unalcol.evolution.Individual;
import unalcol.evolution.Population;
import unalcol.evolution.Selection;

import java.util.Vector;

public class Cross extends GeneticOperator {
    protected Selection selection;

    public Cross(Environment _environment, Selection _selection) {
        super(_environment);
        selection = _selection;
    }

    public Vector<Molecules> apply(Molecules one, Molecules two) {
        // System.out.println("Cross");
        Molecules clone_genome = one.clone(); // @TODO: clonar objeto
        Molecules clone_genome2 = two.clone(); // @TODO: clonar objeto
        int code;
        int num = (int) (Math.random() * (clone_genome.getTotalGroups()) - 1);
        int num2 = (int) (Math.random() * (clone_genome2.getTotalGroups()) - 1);

        Node aGroup1 = one.getGroupAt(num);
        Node aGroup2 = two.getGroupAt(num2);

        searchAndReplace(clone_genome.getMoleculeByRootGroup(), num, aGroup2, true, ((MoleculesEnviroment) environment).aGC);
        searchAndReplace(clone_genome2.getMoleculeByRootGroup(), num2, aGroup1, true, ((MoleculesEnviroment) environment).aGC);

        Vector<Molecules> v = new Vector<>();
        v.add(clone_genome);
        v.add(clone_genome2);
        return v;
    }

    /**
     * Apply the operator over the given individuals
     *
     * @param population Source population
     * @param x          Individual used as first parent
     * @return A collection of individuals generated by the operator
     */
    public Vector<Individual> apply(Population population, int x) {
        Vector<Individual> children = null;
        if (population != null && selection != null) {
            Vector<Individual> parents = selection.choose(population, x);
            // only for two children
            Vector<Molecules> genomes = apply((Molecules) parents.get(0).getGenome(),
                    (Molecules) parents.get(1).getGenome());
            children = new Vector<Individual>();
            children.add(new Individual<Molecules, Molecules>(genomes.get(0)));
            children.add(new Individual<Molecules, Molecules>(genomes.get(1)));
        }
        return children;
    }

    /**
     * Return the genetic operator arity
     *
     * @return the genetic operator arity
     */
    public int getArity() {
        return 2;
    }

}
